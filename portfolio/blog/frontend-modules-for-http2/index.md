With the advent of HTTP 2.0 the old conventions of bundling and minifying a JavaScript application no longer completely apply. This is an opourtunity to **reinvent the way we handle module resolution** to achive two core tennets.

1. **Lazy Loading** - Download the minimum amount of code to make your application work.

2. **Multiplexing** - Speed up fetching your application through concurrent downloads, bearing in mind legacy support, and the header overhead of too many modules loading at the same time.

3. **Caching** - Moving control of caching to the client.

I propose a **Module Import API and Toolset** built on top of SystemJS (A polyfill of native imports) called [**Frontend Modules API**](https://www.npmjs.com/package/fma) from which modules can be served in any format (bundles, individual files, CommonJS, etc).

```js
import React from 'react';

// Compiles down to
SystemJS.import('react');

// Which hits the endpoint
let moduleAPI = '/modules/react';

// And returns a js file 'vendor.min.js' generated by Webpack or SystemJS.
``` 

## Prior Art

### Webpack 2 

Webpack is a static JavaScript bundler that's extremely extendable.

Throughout the history of Webpack its community had a wide range of solutions to the problem of managing modules.

- **Bundling** - As successor to [Browserify](http://browserify.org/), Webpack came with bundling by default.

- **Import Anything** - Modules didn't have to simply be `.js` files, you could even import `.css`, `.html`, or any other format.

- **Chunks** - Split the application into chunks, such as a `vendor.js` for your libraries and `main.js` for your main application code.

- **Aggressive Splitting** - A [recent approach](https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.y6vm515rv) where files are separated according to an approximate size range that would generally be the most performant to download in HTTP2. 

- **Web Workers** - Handling the fetching of modules on a separate thread, this could even be set up to create logic that lets developers handle caching.

### SystemJS

**SystemJS** indexes files in a registry similar to `node_modules` on runtime, which can be mapped in any way your use case sees fit. Combine this with a mix of static compilation/minification and you have the potential of having an extremely dynamic application.

Lets take a simple example where a frontend router is supposed to fetch a view. 

```js
import {About} from './views';

export default () => (
  <About/>
);
```

In SystemJS, that import statment is converted to a **Promise** to the registry that `'./views'` contains a module with an `About` React class.

The ideal scenario would be a mix of both *static* and *dynamic* runtimes, using one or the other whenever nessecary, instead of having to be forced to only static analysis like in Webpack (even though that works really well for most use cases).

## Our Method

### Backend

```bash
npm i fma-express-mongodb -S
```

To hook up the system on the backend, all you need to do is add a module to your express application.

```js
import ModuleRouter from 'fma-express-mongodb';
import { mongoHandle } from './database-service';

// After setting up an express application
app.use('modules', ModuleRouter({database: mongoHandle}));
```

You can even go further by hooking it up to GraphQL:

```bash
npm i fma-graphql-mongodb -S
```

```js
import FMASchema from 'fma-graphql-mongodb';
import { mongoHandle } from './database-service';

let schema = new GraphQLSchema({
    modules: FMASchema(mongoHandle)
    // ...
  });
```

From there you could use a tool like [Greed](https://github.com/hyperfuse/greed) to fetch metadata on the frontend. This is especially useful for **plugin systems** where you want to feed your plugin metadata from the database.

### CLI

```bash
npm i fma-cli -D
```

To quickly compile your application for use in this system, you simply need to type:

```bash
fma-cli
```

This will automatically compile your application into minified modules in a `modules/` folder where this function is called.

```bash
|- modules/
  |- vendor.js      # Chunk containing primary dependencies
  |- react          # Symlink to vendor.js
  |- react-dom      # Symlink to vendor.js
  |- react-router   # ...
  |- ...
  |- alain.xyz/
    |- index.js     # Module 'alain.xyz'
    |- views/       # Module blog, split for lazy loading
      |- about.js   # Module about, split for lazy loading
... 
```

To pouplate your database with package.json metadata of your modules, type:

```
fma-cli mongodb
```